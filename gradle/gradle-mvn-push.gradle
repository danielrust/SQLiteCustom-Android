/*
 * Copyright 2013 Chris Banes
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Changes from original:
 * - Different username and password variables LDS_XXXX
 * - Added support for optional dependencies
 * - Temp Disabled Javadoc due to KotlinDoc issues
 * + Default Repo set to LDS Nexus
 */
buildscript {

  repositories {
    jcenter()
  }

  dependencies {
    // Add dependency for build script,
    // so we can access Git from our
    // build script
    classpath 'org.ajoberstar:grgit:1.1.0'
  }
}

apply plugin: 'maven'
apply plugin: 'signing'

version = VERSION_NAME
group = GROUP

def isReleaseBuild() {
  return project.hasProperty('release') && project.release
}

def getReleaseRepositoryUrl() {
  return hasProperty('RELEASE_REPOSITORY_URL') ? RELEASE_REPOSITORY_URL
          : "https://code.lds.org/nexus/content/repositories/mobile-releases/"
}

def getSnapshotRepositoryUrl() {
  return hasProperty('SNAPSHOT_REPOSITORY_URL') ? SNAPSHOT_REPOSITORY_URL
          : "https://code.lds.org/nexus/content/repositories/mobile-snapshots/"
}

def getRepositoryUsername() {
  return hasProperty('LDS_NEXUS_USERNAME') ? LDS_NEXUS_USERNAME : ""
}

def getRepositoryPassword() {
  return hasProperty('LDS_NEXUS_PASSWORD') ? LDS_NEXUS_PASSWORD : ""
}

def getGitUsername() {
  return hasProperty('LDS_GIT_USERNAME') ? LDS_GIT_USERNAME : ""
}

def getGitPassword() {
  return hasProperty('LDS_GIT_PASSWORD') ? LDS_GIT_PASSWORD : ""
}

ext {
  git = org.ajoberstar.grgit.Grgit.open(dir: file('..'), creds: new org.ajoberstar.grgit.Credentials(username: getGitUsername(), password: getGitPassword()))
}

afterEvaluate { project ->
  uploadArchives {
    repositories {
      mavenDeployer {
        beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }

        doFirst {
          if (isReleaseBuild()) {
            if (git.tag.list().collect { it.getName() }.contains(VERSION_NAME)) {
              println "Tag $VERSION_NAME already exists"
              println "Skipping upload"
              throw new StopExecutionException()
            }
          }
        }

        doLast {
          if (isReleaseBuild()) {
            git.tag.add(name: VERSION_NAME)
            git.push(tags: true)
            println "Tag Successful"
          }
          println "Upload Successful"
        }

        pom.groupId = GROUP
        pom.artifactId = POM_ARTIFACT_ID
        pom.version = VERSION_NAME

        repository(url: getReleaseRepositoryUrl()) {
          authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
        }
        snapshotRepository(url: getSnapshotRepositoryUrl()) {
          authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
        }

        pom.project {
          name POM_NAME
          packaging POM_PACKAGING
          description POM_DESCRIPTION
          url POM_URL

          scm {
            url POM_SCM_URL
            connection POM_SCM_CONNECTION
            developerConnection POM_SCM_DEV_CONNECTION
          }

          licenses {
            license {
              name POM_LICENCE_NAME
              url POM_LICENCE_URL
              distribution POM_LICENCE_DIST
            }
          }

          developers {
            developer {
              id POM_DEVELOPER_ID
              name POM_DEVELOPER_NAME
            }
          }
        }

        // mark optional dependencies
//                pom.withXml {
//                    asNode().dependencies.dependency.findAll { xmlDep ->
//                        if (project.configurations.optional.allDependencies.findAll { dep ->
//                            xmlDep.groupId.text() == dep.group && xmlDep.artifactId.text() == dep.name
//                        }) {
//                            def xmlOptional = xmlDep.optional[0];
//                            if (!xmlOptional) {
//                                xmlOptional = xmlDep.appendNode('optional')
//                            }
//                            xmlOptional.value = 'true';
//                        }
//                    }
//                }
      }
    }
  }

  signing {
    required { isReleaseBuild() && gradle.taskGraph.hasTask("uploadArchives") }
    sign configurations.archives
  }

  if (project.getPlugins().hasPlugin('com.android.application') ||
          project.getPlugins().hasPlugin('com.android.library')) {
    task install(type: Upload, dependsOn: assemble) {
      repositories.mavenInstaller {
        configuration = configurations.archives

        pom.groupId = GROUP
        pom.artifactId = POM_ARTIFACT_ID
        pom.version = VERSION_NAME

        pom.project {
          name POM_NAME
          packaging POM_PACKAGING
          description POM_DESCRIPTION
          url POM_URL

          scm {
            url POM_SCM_URL
            connection POM_SCM_CONNECTION
            developerConnection POM_SCM_DEV_CONNECTION
          }

          licenses {
            license {
              name POM_LICENCE_NAME
              url POM_LICENCE_URL
              distribution POM_LICENCE_DIST
            }
          }

          developers {
            developer {
              id POM_DEVELOPER_ID
              name POM_DEVELOPER_NAME
            }
          }
        }
      }
    }

//    task androidJavadocs(type: Javadoc) {
//      source = android.sourceSets.main.java.source
//      classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
//    }
//
//    task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
//      classifier = 'javadoc'
//      from androidJavadocs.destinationDir
//    }

    task androidSourcesJar(type: Jar) {
      classifier = 'sources'
      from android.sourceSets.main.java.source
    }
  } else {
    install {
      repositories.mavenInstaller {
        pom.groupId = GROUP
        pom.artifactId = POM_ARTIFACT_ID
        pom.version = VERSION_NAME

        pom.project {
          name POM_NAME
          packaging POM_PACKAGING
          description POM_DESCRIPTION
          url POM_URL

          scm {
            url POM_SCM_URL
            connection POM_SCM_CONNECTION
            developerConnection POM_SCM_DEV_CONNECTION
          }

          licenses {
            license {
              name POM_LICENCE_NAME
              url POM_LICENCE_URL
              distribution POM_LICENCE_DIST
            }
          }

          developers {
            developer {
              id POM_DEVELOPER_ID
              name POM_DEVELOPER_NAME
            }
          }
        }
      }
    }

    task sourcesJar(type: Jar, dependsOn: classes) {
      classifier = 'sources'
      from sourceSets.main.allSource
    }

    task javadocJar(type: Jar, dependsOn: javadoc) {
      classifier = 'javadoc'
      from javadoc.destinationDir
    }
  }

  if (JavaVersion.current().isJava8Compatible()) {
    allprojects {
      tasks.withType(Javadoc) {
        options.addStringOption('Xdoclint:none', '-quiet')
      }
    }
  }

  artifacts {
    if (project.getPlugins().hasPlugin('com.android.application') ||
            project.getPlugins().hasPlugin('com.android.library')) {
      archives androidSourcesJar
//      archives androidJavadocsJar
    } else {
      archives sourcesJar
      archives javadocJar
    }
  }
}